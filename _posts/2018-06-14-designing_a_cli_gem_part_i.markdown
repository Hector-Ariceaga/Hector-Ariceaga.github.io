---
layout: post
title:      "Designing a CLI Gem: Part I"
date:       2018-06-14 18:24:44 +0000
permalink:  designing_a_cli_gem_part_i
---

I wanted to dedicate some extra time to reviewing the process of working through this project, wherein I am designing a Ruby Gem. As such, I am breaking down the project into two parts. This first post will be reviewing how I selected what purpose my gem would serve, preparing for the project, drafting plans for the gem, initial obstacles, and ultimately what I would like the completed gem to look like.

### The Man Behind the Curtain
It always comes as a surprise to me when working with code that the actual coding itself takes up a relatively small portion of time. Once the appropriate amount of time has been spent laying the framework, the code itself is written more quickly and debugged even faster. In many ways it reminds me of the old adage "measure twice, cut once".  I would also argue, likely without much pushback from others, that it is easier to solve a problem when you already have some idea of what the solution should be. That so little time is spent actually writing code suggests there is a substantial amount of work going on behind the scenes. The finished product, the completed code, is important. It is the culmination of countless hours of work and preparation. However, the preparation itself is vital. The process of getting to the finished product is what must be replicated time and time again. It can be liked to the Man Behind the Curtain that does his work to create the magic code that dazzles us. Only the finished product, and the toiling that was done to arrive at the product, is no illusion.

### Finding a Problem
This part should be easy right? We all find ourselves wishing we had solutions to problems of varying difficulty. We all find ourselves doing things inefficiently and thinking silently (or not so silently) 'There has got to be a better way.' It turns out, more often than not, we move right along with our day. When we are not in problem seeking mode, we encounter problems left and right. However, when we are put on the spot that endless well of problems we could draw from suddenly dries up. You may have even noticed that the more desperate you are to find some problem to solve the less likely it is that it is really a problem that needs solving (I call this the 'I want to create the next startup!' dilemma). In fairness, this may not mirror your experience, but it sure describes mine. If this does sound familiar, then perhaps what works for me will work for you as well. Try this: dial it back. You may be feeling the pressure, but if you tune into problem receiver mode, rather than problem seeker mode, you might find that things which need fixing or tasks that can be improved will start popping up AND you will be ready for them. What do I mean? Take for example one recent experience, which ultimately led me to the problem my gem sets out to solve. 

As this project was approaching, I found myself in the pattern described above. I decided to take a bit of a breather and stop trying to find the perfect project idea. A few days later I was having a conversation with my father, who is also a tech enthusiast. He was in the middle of describing how he is implementing some new web tools in his company's marketing strategy when something magical happened. He described a problem he was running into. It was significant enough to mention, but nothing so important that it was causing his company's operations to grind to a halt. It was a simple inconvenience. It was a normal part of a conversation where one person relays a minor complaint to the other. And it was perfect. Here I had been racking my brain for a problem that met all of these requirements that I built up and instead it was gifted to me. I'm not suggesting that all ideas will be given to you by others, but I am suggesting that if you are receptive to new ideas in your daily experiences you will have a wealth of inspiration to draw from.


### Proposing a Solution
This part might not be so difficult. Especially if you are just looking for a problem that corresponds to a set of tools you are hoping to utilize in your solution. In my case, I knew I was hoping to utilize a Ruby Gem, which I would build, to provide information from a scraped site in the form of a CLI. Once I had a problem to solve, I was able create specifications, separate from those assigned to me, that I wanted my gem to meet. Creating those specifications was simply a matter of matching features to meet specifications. You might find, as I did, the challenge lies less in proposing a solution, but in proposing a solution that is focused, complete, meets all the requirements (if it is an assigned project) and not complicated (at least in the beginning).

Below is a brief mockup of how I decided on some features:

#### Specification => Feature
* User only interested in specific information => Scrape from specific site
* User only interested in new information (less than 24 hours old) => Display only new info (<24 hours old) from scraped data
* Tell at a glance 4 specific details of information => Design CLI menu to display those 4 specific details
* Give additional details on returned information => Allow user to gather additional details by navigating within CLI

This is a great place to start. By getting this far you have an idea of a problem you want to solve, the primary tool you are hoping to use to solve the problem, and some of the features you would like your tool to possess. Is it time to start writing some code? It could be. Although, I would suggest completing one more step, research. Now is a great time to utilize your resources. Before starting, think about what kind of code you might be working with as you solve this problem and implement these features. Ask yourself some questions: Will I be building objects? What types of properties will those objects have? What levels of abstraction will I be working with? What kind of classes will I need or want to implement? What problems do I foresee occurring? What are some concepts that I might need to implement that I am not familiar with?

Do some reading. Maybe watch a quick tutorial. Don't get too hung up on this portion. The goal here is not to gain a mastery of anything, but rather to familiarize (or familiarize) yourself with some basic concepts. This well let you know where your go to resources are if you get stuck along the way. After drafting a plan, doing some research, and getting some idea of what I would be working with, I was ready to get started.

### Working the Problem
I like to a have a clean desk before I start working on a new project. The same goes for when I am working code. I want to get everything tidied up and ready to go, before I start. This inevitably saves me headaches in the future that could be caused by clutter or poor planning. In this instance, I needed to start to be setting up my file structure and checking my dependencies to make sure everything was ready to go. It's important to remember that things might look very different from the way they look in the beginning, they likely will. A blank screen can be pretty intimidating so getting forward momentum will be crucial in keeping yourself from stalling out early on. 

Once I had my file structure built out, I began to write some pseudo code so I had a rough idea of the flow of my gem. Next came some simple method stubs. From there I was able to start writing the CLI. Why start there? I was following advice from those who had done this several times before. Remember that research step I mentioned earlier? I was leaning on the resources available to me. The process that I saw described of developing a CLI made sense, so I adopted one of the principles. I started the design of the gem from where it would interact with the user. From there I was able to proceed with the rest of code. 

I didn't have any issues until I ran into an error when I tried to open the HTML of the site I was trying to scrape. I went back to the resources I had been poring over earlier and found a potential solution. I thought about why it might work, and I implemented it. It worked wonderfully. On I went. I next found myself stuck while trying to obtain some of the information I wanted to scrape from the HTML. It just so happens that the information I wanted was buried in JavaScript. It was time to go back to my resources. I looked around and this time didn't find a workable solution. What I did get was a better understanding of how to narrow my search. So I started from there and continued to narrow my search until I was finally able to select the information I needed. From there it was smooth sailing, which I attribute wholly to the prep work I had done in the beginning.

### Build on the Solution
I haven't completed the gem yet. I have one final piece of code to implement and I still need to refactor the code so it is more concise. This brings me to the last step in my process, building on my solution. While almost all of my code is written, I know there is still much that can be improved on. There are methods to shorten, selectors that can be refined, and maybe in the future new features to be added. The solution is dynamic. It can be improved upon. It should be improved upon. Once my gem is complete I will be back to reflect on the process of refactoring the code, submitting it to RubyGems, and the code review process.

